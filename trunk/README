These files provide the routine 'mrrr'. Its purpose is to compute all 
or a subset of eigenvalues and optionally eigenvectors of a symmetric 
tridiagonal matrix. 'mrrr' is based on the algorithm of Multiple 
Relatively Robust Representations (MRRR). The routine thereby targets 
multi-core processors and SMP systems made out of them. The 
implementation is based on LAPACK's routine 'dstemr'.


Building the archive libmrrr.a:
--------------------------------
1) In the folder INSTALL, depending on the compiler used, 
   replace the file 'make.inc' (which assumes GNU gcc) 
   with the corresponding file. 
   For example if you want to use Intel's compilers: 
   $cp ./INSTALL/make.inc.intel ./make.inc
   If you do not find a file matching your compiler, then use any of 
   the files as a basis to edit.
2) Edit the file 'make.inc' according to your system.
3) Run make.


Using libmrrr.a:
----------------
The folder EXAMPLES contains simple examples of how to use the routine 
'mrrr' in C and Fortran code. Edit the 'Makefile' in these folders if 
you do not use the GNU compilers and run 'make' to compile the 
examples.

In general, the code that calls 'mrrr' needs to be linked to the 
library 'libmrrr.a', which is created in the LIB folder. 

Below are given the C and Fortran prototypes of the function 'mrrr'.
For more information please see 'INCLUDE/mrrr.h'.


######################################################################
# C function prototype:                                              #
###################################################################### 
#                                                                    #
# int mrrr(char *jobz, char *range, int *n, double  *D,              #
#          double *E, double *vl, double *vu, int *il, int *iu,      #
#          int *tryrac, int *m, double *W, double *Z, int *ldz,      #
#	   int *Zsupp);                                              #
#                                                                    #
# INPUTS:                                                            #
# -------                                                            #
# jobz              "N" or "n" - compute only eigenvalues            #
#                   "V" or "v" - compute also eigenvectors           #
#                   "C" or "c" - count the maximal number of         #
#                                locally computed eigenvectors       #
# range             "A" or "a" - all                                 #
#                   "V" or "v" - by interval: (VL,VU]                #
#                   "I" or "i" - by index:     IL-IU                 #
# n                 Matrix size                                      #
# ldz               Leading dimension of eigenvector matrix Z;       #
#                   often equal to matrix size n                     #
#                                                                    #
# INPUT + OUTPUT:                                                    #
# ---------------                                                    #
# D (double[n])     Diagonal elements of tridiagonal T.              #
#                   (On output the array will be overwritten).       #
# E (double[n])     Off-diagonal elements of tridiagonal T.          #
#                   First n-1 elements contain off-diagonals,        #
#                   the last element can have an abitrary value.     #
#                   (On output the array will be overwritten.)       #
# vl                If range="V", lower bound of interval            #
#                   (vl,vu], on output refined.                      #
#                   If range="A" or "I" not referenced as input.     #
#                   On output the interval (vl,vu] contains ALL      #
#                   the computed eigenvalues.                        #
# vu                If range="V", upper bound of interval            #
#                   (vl,vu], on output refined.                      #
#                   If range="A" or "I" not referenced as input.     #
#                   On output the interval (vl,vu] contains ALL      #
#                   the computed eigenvalues.                        #
# il                If range="I", lower index (1-based indexing) of  #
#                   the subset 'il' to 'iu'.                         #
#                   If range="A" or "V" not referenced as input.     #
#                   On output the eigenvalues with index 'il' to 'iu'#
#                   are computed.                                    #
# iu                If range="I", upper index (1-based indexing) of  #
#                   the subset 'il' to 'iu'.                         #
#                   If range="A" or "V" not referenced as input.     #
#                   On output the eigenvalues with index 'il' to 'iu'# 
#                   are computed.                                    #
# tryrac            0 - do not try to achieve high relative accuracy.#
#                   1 - relative accuracy will be attempted;         #
#                       on output it is set to zero if high relative #
#                       accuracy is not achieved.                    #
#                                                                    #
# OUTPUT:                                                            #
# -------                                                            #
# m                 Number of eigenvalues and eigenvectors computed. #
#                   If jobz="C", 'm' will be set to the number of    #
#                   eigenvalues/eigenvectors that will be computed.  #
# W (double[n])     Eigenvalues                                      #
#                   The first 'm' entries contain the eigenvalues.   #
# Z                 Eigenvectors                                     #
# (double[n*m])     Enough space must be provided to store the       #
#                   vectors. 'm' should be bigger or equal           #
#                   to 'n' for range="A" and 'iu-il+1' for range="I".#
#                   For range="V" the minimum 'm' can be queried     #
#                   using jobz="C".                                  #
# Zsupp             Support of eigenvectors, which is given by       #
# (double[2*n])     Z[2*i] to Z[2*i+1] for the i-th eigenvector      #
#                   stored locally (1-based indexing).               #
#                                                                    #
######################################################################


######################################################################
# Fortran prototype:                                                 #
######################################################################
#                                                                    #
# MRRR(JOBZ, RANGE, N, D, E, VL, VU, IL, IU, TRYRAC, M, W,           #
#      Z, LDZ, ZSUPP, INFO)                                          #
#                                                                    #
# CHARACTER        JOBZ, RANGE                                       #
# INTEGER          N, IL, IU, TRYRAC, M, LDZ, ZSUPP(*), INFO         #
# DOUBLE PRECISION D(*), D(*), VL, VU, W(*), Z(*,*)                  #
######################################################################

The number of threads created can be specified via the environment 
variable PMR_NUM_THREADS. In case this variable is not 
defined, then the routine will create as many threads as specified by 
the variable DEFAULT_NUM_THREADS (which is set in 'mrrr.h'). 


For convinience there are also routines for the symmetric and 
Hermitian eigenproblem added that make use of the multi-threaded MRRR. 
Using LAPACK notation they are called DSYEIG and ZHEEIG. For the 
reduction and back-transformation the routines call the corresponding 
LAPACK routines. Therefore LAPACK is required to run the routines. 
Simply code snippets of how to call the functions are included in the 
examples folder.
The prototypes are similar to LAPACK's "dsyevx" and are as follows.

The symmetric case:

######################################################################
# C function prototype:                                              #
###################################################################### 
#                                                                    #
# int dsyeig(char *jobz, char *range, char *uplo, int *n, double *A, #
#            int *lda, double *vl, double *vu, int *il, int *iu,     #
#	     int *m, double *W, double *Z, int *ldz);                #
#                                                                    #
# Arguments:                                                         #
# ----------                                                         #
#                                                                    #
# INPUTS:                                                            #
# -------                                                            #
# jobz              "N" - compute only eigenvalues                   #
#                   "V" - compute also eigenvectors                  #
# range             "A" - all                                        #
#                   "V" - by interval: (VL,VU]                       #
#                   "I" - by index:     IL-IU                        #
# uplo              "L" - Upper triangle of A stored                 #
#                   "U" - Lower triangle of A stored                 #
# n                 Order of the matrix A                            #
# lda               Leading dimension of matrix A;                   #
#                   often equal to matrix size n                     #
# ldz               Leading dimension of eigenvector matrix Z;       #
#                   often equal to matrix size n                     #
#                                                                    #
# INPUT + OUTPUT:                                                    #
# ---------------                                                    #
# A                 On entry symmetric input matrix, stored          #
# (double[lda*n])   in column major ordering. Depending on the       #
#                   value of 'uplo' only the upper or lower          #
#                   triangular part is referenced.                   #
#                   (On output the array will be overwritten).       #
# vl                If range="V", lower bound of interval            #
#                   (vl,vu], on output refined.                      #
#                   If range="A" or "I" not referenced as input.     #
#                   On output the interval (vl,vu] contains ALL      #
#                   the computed eigenvalues.                        #
# vu                If range="V", upper bound of interval            #
#                   (vl,vu], on output refined.                      #
#                   If range="A" or "I" not referenced as input.     #
#                   On output the interval (vl,vu] contains ALL      #
#                   the computed eigenvalues.                        #
# il                If range="I", lower index (1-based indexing) of  #
#                   the subset 'il' to 'iu'.                         #
#                   If range="A" or "V" not referenced as input.     #
#                   On output the eigenvalues with index il to iu    #
#                   are computed.                                    #
# iu                If range="I", upper index (1-based indexing) of  #
#                   the subset 'il' to 'iu'.                         #
#                   If range="A" or "V" not referenced as input.     #
#                   On output the eigenvalues with index il to iu    #
#                   are computed.                                    #
#                                                                    #
# OUTPUT:                                                            #
# -------                                                            #
# m                 Number of eigenvalues and eigenvectors computed. #
# W (double[n])     Eigenvalues                                      #
#                   The first 'm' entries contain the eigenvalues.   #
# Z                 Eigenvectors.                                    #
# (double[n*m])     Enough space must be provided to store the       #
#                   vectors. 'm' should be bigger or equal           #
#                   to 'n' for range="A" or "V" and 'iu-il+1' for    #
#                   range="I".                                       #
#                                                                    #
# RETURN VALUE:                                                      #
# -------------                                                      #
#                 0 - Success                                        #
#                 1 - Wrong input parameter                          #
#                 2 - Misc errors                                    #
######################################################################

######################################################################
# Fortran prototype:                                                 #
######################################################################
#                                                                    #
# CALL DSYEIG(JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,          #
#             M, W, Z, LDZ, INFO)                                    #
#                                                                    #
# CHARACTER        JOBZ, RANGE, UPLO                                 #
# INTEGER          N, IL, IU, M, LDA, LDZ, INFO                      #
# DOUBLE PRECISION A(*,*), VL, VU, W(*), Z(*,*)                      #
#                                                                    #
######################################################################


The Hermitian case (only added to 'libmrrr.a' if specified in 
'make.inc'):

######################################################################
# C function prototype:                                              #
###################################################################### 
#                                                                    #
# int zheeig(char *jobz, char *range, char *uplo, int *n,            #
#	   double complex *A, int *lda, double *vl, double *vu,      #
#	   int *il, int *iu, int *m, double *W, double complex *Z,   #
#	   int *ldz);                                                #
#                                                                    #
# Arguments:                                                         #
# ----------                                                         #
#                                                                    #
# INPUTS:                                                            #
# -------                                                            #
# jobz              "N" - compute only eigenvalues                   #
#                   "V" - compute also eigenvectors                  #
# range             "A" - all                                        #
#                   "V" - by interval: (VL,VU]                       #
#                   "I" - by index:     IL-IU                        #
# uplo              "L" - Upper triangle of A stored                 #
#                   "U" - Lower triangle of A stored                 #
# n                 Order of the matrix A                            #
# lda               Leading dimension of matrix A;                   #
#                   often equal to matrix size n                     #
# ldz               Leading dimension of eigenvector matrix Z;       #
#                   often equal to matrix size n                     #
#                                                                    #
# INPUT + OUTPUT:                                                    #
# ---------------                                                    #
# A                 On entry Hermitian input matrix, stored          #
# (double complex   in column major ordering. Depending on the       #
#  [lda*n])         value of 'uplo' only the upper or lower          #
#                   triangular part is referenced.                   #
#                   (On output the array will be overwritten).       #
# vl                If range="V", lower bound of interval            #
#                   (vl,vu], on output refined.                      #
#                   If range="A" or "I" not referenced as input.     #
#                   On output the interval (vl,vu] contains ALL      #
#                   the computed eigenvalues.                        #
# vu                If range="V", upper bound of interval            #
#                   (vl,vu], on output refined.                      #
#                   If range="A" or "I" not referenced as input.     #
#                   On output the interval (vl,vu] contains ALL      #
#                   the computed eigenvalues.                        #
# il                If range="I", lower index (1-based indexing) of  #
#                   the subset 'il' to 'iu'.                         #
#                   If range="A" or "V" not referenced as input.     #
#                   On output the eigenvalues with index il to iu    #
#                   are computed.                                    #
# iu                If range="I", upper index (1-based indexing) of  #
#                   the subset 'il' to 'iu'.                         #
#                   If range="A" or "V" not referenced as input.     #
#                   On output the eigenvalues with index il to iu    #
#                   are computed.                                    #
#                                                                    #
# OUTPUT:                                                            #
# -------                                                            #
# m                 Number of eigenvalues and eigenvectors computed. #
# W (double[n])     Eigenvalues                                      #
#                   The first 'm' entries contain the eigenvalues.   #
# Z                 Eigenvectors.                                    #
# (double complex   Enough space must be provided to store the       #
#  [n*m])           vectors. 'm' should be bigger or equal           #
#                   to 'n' for range="A" or "V" and 'iu-il+1' for    #
#                   range="I".                                       #
#                                                                    #
# RETURN VALUE:                                                      #
# -------------                                                      #
#                 0 - Success                                        #
#                 1 - Wrong input parameter                          #
#                 2 - Misc errors                                    #
######################################################################

######################################################################
# Fortran prototype:                                                 #
######################################################################
#                                                                    #
# CALL DSYEIG(JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,          #
#             M, W, Z, LDZ, INFO)                                    #
#                                                                    #
# CHARACTER        JOBZ, RANGE, UPLO                                 #
# INTEGER          N, IL, IU, M, LDA, LDZ, INFO                      #
# DOUBLE PRECISION VL, VU, W(*)                                      #
# COMPLEX*16       A(*,*), Z(*,*)                                    #
#                                                                    #
######################################################################



COMMENTS AND BUGS:
petschow@aices.rwth-aachen.de
